# -*- coding: utf-8 -*-
"""Pregunta 1 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F0X2iK7128P_JYS5yd91TNWRUSkol23d
"""

import math
from busquedas_02 import ProblemaBusqueda, aestrella

MAPA = """
******************************
* E     C                    *
*    *****                   *
*    *                       *
**   *      *       **********
*           *                *
*  A        ******  ***      *
*                *           *
*   ******       *           *     
*   *                        *
*   *    *************       *
*                    *       *
*                           B* 
******************************
"""

MAPA = [list(x) for x in MAPA.split("\n") if x] #crea una lista de lista donde cada fila del mapa
#es un lista ejemplo [['*','*','*',' ',' ',' ',' ',' ',','*'],[......],...]

COSTOS = { #diccionario
    "arriba": 1.0,
    "abajo": 1.0,
    "izquierda": 1.0,
    "derecha": 1.0,
    "arriba izquierda": 1.4,
    "arriba derecha": 1.4,
    "abajo izquierda": 1.4,
    "abajo derecha": 1.4,
}

class JuegoLaberinto(ProblemaBusqueda):

    def __init__(self, tablero,salidas,entradas):#recibe el MAPA
        self.tablero = tablero #inicializamos el MAPA
        self.estado_objetivo = (0, 0)
        for y in range(len(self.tablero)): #recorre desde 0 hasta el tamaño del MAPA cordenada Y
            for x in range(len(self.tablero[y])):#recorre desde 0 hasta tamaño del primera lista de listas 
                if self.tablero[y][x].lower() == entradas:
                    self.estado_inicial = (x, y) #busca las cordendas donde esta la entrada e inicializa
                elif self.tablero[y][x].lower() == salidas:
                    self.estado_objetivo = (x, y) #busca las cordendas donde esta la salida e inicializa

        super(JuegoLaberinto, self).__init__(estado_inicial=self.estado_inicial)#inicializa el laberinto

    def acciones(self, estado):
        acciones = []
        for accion in list(COSTOS.keys()):# con el metodo .keys obtine las llaves del diccionario y luego todo eso
            #se convierte en una lista con el metodo (list()) ["arriba","abajo",.....]
            nuevox, nuevoy = self.resultado(estado, accion) #resultado((1,6),"arriba")
            if self.tablero[nuevoy][nuevox] != "*": # verificamos si esas nuevas cordenadas no tengan paredes
                acciones.append(accion)#si esta libre se agrega a la lista la accion "arriba"
        return acciones #retorna las acciones que se pueden realizar 

    def resultado(self, estado, accion): #estado=(2,6) posicion actual 
        #acccion=representa movimiento en una direccion especifica
        x, y = estado 

        if accion.count("arriba"):#si la accion.contiene("arriba") y disminuye en 1
            y -= 1
        if accion.count("abajo"):
            y += 1
        if accion.count("izquierda"):
            x -= 1
        if accion.count("derecha"):
            x += 1

        estado_nuevo = (x, y)
        return estado_nuevo #retorna las nuevas cordenadas

    def es_objetivo(self, estado):
        return estado == self.estado_objetivo # si las cordenas son el objerivo =TRUE si no FALSE

    def costo(self, estado, accion, estado2):
        return COSTOS[accion] # retorna el costo de tomar una accion "arriba"=1.0

    def heuristic(self, estado):
        x, y = estado #cordenadas actuales
        gx, gy = self.estado_objetivo #cordenadas salida
        return math.sqrt((x - gx) ** 2 + (y - gy) ** 2) #formula de distancia euclidiana mientras mas bajo mas cerca
    #si es = 0 ya esta en la salida

def main():
    entradas = "e"
    salidas = ['a','b','c']
    objetos=[] #guarda el instancia del objeto con el mejor camino
    mejorCamino=[] #guarda las cordenadas del mejor camino
    MejorSalida='' #guarda la mejor salida  "a","b","c"

    valor=[]
    i=0
    while True:
        if i==3:
            break
        problema = JuegoLaberinto(MAPA, salidas[i],entradas)
       
        resultado = aestrella(problema, busqueda_en_grafo=True)
        camino =[x[1] for x in resultado.camino()]
        print("distancia : ",
              salidas[i], "es :", len(camino))
        valor.append(len(camino))
        if  len(camino) <= min(valor) and i > 0:
            objetos[0]=problema
            mejorCamino[0]=camino 
            MejorSalida=salidas[i]
        elif i == 0:
            objetos.append(problema)
            mejorCamino.append(camino)
            MejorSalida=salidas[i]
        i += 1
    
    
    for y in range(len(MAPA)):  # imprime el nuevo mapa
        for x in range(len(MAPA[y])):
            if (x, y) == objetos[0].estado_inicial:
                print("E", end='')
            elif (x, y) == objetos[0].estado_objetivo:
                print(MejorSalida, end='')
            elif (x, y) in mejorCamino[0]:
                print(">", end='')
            else:
                print(MAPA[y][x], end='')
        print()

if __name__ == "__main__":
    main()